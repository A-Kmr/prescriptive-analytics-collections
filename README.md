# ðŸ’° Prescriptive Analytics for Collections Optimization

![Python](https://img.shields.io/badge/Python-3.9+-blue.svg)
![Streamlit](https://img.shields.io/badge/Streamlit-App-FF4B4B.svg)
![Optimization](https://img.shields.io/badge/Optimization-Linear%20Programming-success)

> **Business Impact:** Demonstrated a **27.1% uplift** in daily recoverable revenue by shifting from a traditional "Risk-Based" strategy to a "Value-Based" Prescriptive Analytics engine.

## ðŸ“Œ Executive Summary
In financial collections, call center capacity is a hard constraint (e.g., 50 calls/day). Traditional strategies prioritize accounts with the highest **Probability of Default (PD)**. This approach often leads to inefficient resource allocationâ€”agents spend time chasing low-balance accounts simply because they are "risky," while missing high-value opportunities.

This project implements a **Prescriptive Analytics Engine** that optimizes resource allocation. By combining **Credit Risk Modeling** (PD/LGD/EAD framework) with **Mathematical Optimization** (Linear Programming), the model identifies the specific set of accounts that maximizes **Expected Recovery** under strict capacity constraints.

---

## ðŸ“Š Key Results

The optimization engine was tested against two baseline strategies on a synthetic dataset of 10,000 invoices with a daily capacity of 50 calls.

| Strategy | Logic | Daily Recovery ($) | Performance vs Naive |
|----------|-------|--------------------|----------------------|
| **Random** | Random Selection | ~$7,160 | -76% |
| **Naive (Baseline)** | Highest Risk (PD) First | ~$30,700 | Baseline |
| **ML + Optimization** | **Maximize Expected Value** | **~$39,000** | **+27.1% ðŸš€** |

---

## ðŸŽ¯ Credit Risk Framework

This project implements the industry-standard credit risk calculation to determine the **Expected Value** of a collection call:

$$\text{Expected Recovery} = \text{EAD} \times \text{PD} \times \text{LGD} \times \text{Intervention Effect}$$

Where:
* **PD (Probability of Default):** The likelihood the customer will not pay (Predicted via XGBoost/Random Forest).
* **EAD (Exposure at Default):** The outstanding invoice amount (Current Balance).
* **LGD (Loss Given Default):** The percentage of the debt lost if a default occurs (Predicted or Assumed).
* **Intervention Effect:** The probability lift generated by a phone call (e.g., calling reduces default risk by 30%).

**The Shift:**
* **Traditional:** Sort by $PD$ (Risk only).
* **Optimized:** Sort by $EAD \times PD \times LGD$ (Value).

---

## ðŸ“ˆ Visualizing the Strategy Shift

The scatter plot below reveals exactly *why* the optimization engine outperforms the baseline.

<img width="405" height="263" alt="image" src="https://github.com/user-attachments/assets/f0077663-3732-449c-8384-03e174a8d9fb" />

**What this shows:**
* **X-axis:** Probability of Default (Risk).
* **Y-axis:** Outstanding Balance (Value).
* **Red Dots (Naive Strategy):** The baseline strategy clusters on the far right. It captures high risk, but often ignores value (e.g., chasing a \$100 debt with 90% risk).
* **Green X's (Optimized Strategy):** The engine identifies **"Whales"**â€”accounts with moderate risk (30-50%) but high balances (\$10k+). These are the opportunities that drive the 27% revenue uplift.

---

## ðŸ”¬ Model Performance

### Risk Model (Random Forest)
* **ROC-AUC:** 0.84 (Strong discrimination between payers and defaulters).
* **Brier Score:** 0.16 (Low score indicates well-calibrated probabilities).
* **Calibration:** Applied **Isotonic Regression** to ensure the predicted probabilities are mathematically accurate for expected value calculations.

### Optimization Performance
* **Solve Time:** <2 seconds for 10,000 accounts.
* **Optimality:** 100% (Guaranteed optimal solution via Linear Programming).

---


## ðŸ’» How to Run This Project

### Prerequisites
```bash
pip install -r requirements.txt
```

### 1. Generate Data
Create the synthetic dataset:
```bash
python generate_data.py
```

### 2. Train Models
Train the Risk (PD) and Severity (LGD) models:
```bash
python train_model.py
```

### 3. Run Optimization
Execute the Linear Programming solver to see the results in your terminal:
```bash
python optimize.py
```

### 4. Launch Dashboard
Start the interactive web app:
```bash
streamlit run app.py
```
